<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA_project: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA_project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95aef3970ce701d8f89ad4485127f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad95aef3970ce701d8f89ad4485127f99">addNode_RWG</a> (int id, double longitude, double latitude)</td></tr>
<tr class="separator:ad95aef3970ce701d8f89ad4485127f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5783fef9d7c4a7776358ab1b18ca8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae5783fef9d7c4a7776358ab1b18ca8a7">addEdge_RWG</a> (int origin, int destination, double distance)</td></tr>
<tr class="separator:ae5783fef9d7c4a7776358ab1b18ca8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4afa47b86c9ced3a3c64873ea9388a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afe4afa47b86c9ced3a3c64873ea9388a">addEdge</a> (int origem, int destino, double distancia)</td></tr>
<tr class="memdesc:afe4afa47b86c9ced3a3c64873ea9388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph.  <a href="class_graph.html#afe4afa47b86c9ced3a3c64873ea9388a">More...</a><br /></td></tr>
<tr class="separator:afe4afa47b86c9ced3a3c64873ea9388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9584cbd89db821348d0e019ee9457ae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9584cbd89db821348d0e019ee9457ae">getMinCost</a> () const</td></tr>
<tr class="memdesc:aa9584cbd89db821348d0e019ee9457ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum cost of the best path found.  <a href="class_graph.html#aa9584cbd89db821348d0e019ee9457ae">More...</a><br /></td></tr>
<tr class="separator:aa9584cbd89db821348d0e019ee9457ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e437958267353f4d3b889a16828b6e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a27e437958267353f4d3b889a16828b6e">getDistance</a> (int source, int destination)</td></tr>
<tr class="memdesc:a27e437958267353f4d3b889a16828b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two nodes in the graph.  <a href="class_graph.html#a27e437958267353f4d3b889a16828b6e">More...</a><br /></td></tr>
<tr class="separator:a27e437958267353f4d3b889a16828b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1638b7cf4d451d148b3db8377372b0e1"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1638b7cf4d451d148b3db8377372b0e1">getBestPath</a> () const</td></tr>
<tr class="memdesc:a1638b7cf4d451d148b3db8377372b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best path found in the graph.  <a href="class_graph.html#a1638b7cf4d451d148b3db8377372b0e1">More...</a><br /></td></tr>
<tr class="separator:a1638b7cf4d451d148b3db8377372b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475e4fc3514ebd7c0e6cb085a052a50f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a475e4fc3514ebd7c0e6cb085a052a50f">tspBacktracking</a> ()</td></tr>
<tr class="memdesc:a475e4fc3514ebd7c0e6cb085a052a50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves TSP using backtracking.  <a href="class_graph.html#a475e4fc3514ebd7c0e6cb085a052a50f">More...</a><br /></td></tr>
<tr class="separator:a475e4fc3514ebd7c0e6cb085a052a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ed70e7026d9638753681e0c052f7cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a99ed70e7026d9638753681e0c052f7cb">tspBacktrackingUtil</a> (int currNode, int depth, double currCost)</td></tr>
<tr class="memdesc:a99ed70e7026d9638753681e0c052f7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for the backtracking algorithm.  <a href="class_graph.html#a99ed70e7026d9638753681e0c052f7cb">More...</a><br /></td></tr>
<tr class="separator:a99ed70e7026d9638753681e0c052f7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d624a7d508563ac165fe1add39e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a631d624a7d508563ac165fe1add39e7f">tspBacktracking_RWG</a> ()</td></tr>
<tr class="memdesc:a631d624a7d508563ac165fe1add39e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves TSP for a real-world graph using backtracking.  <a href="class_graph.html#a631d624a7d508563ac165fe1add39e7f">More...</a><br /></td></tr>
<tr class="separator:a631d624a7d508563ac165fe1add39e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9816ca66208318b4092a55b9ad988e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5d9816ca66208318b4092a55b9ad988e">tspTriangularApproximation</a> ()</td></tr>
<tr class="memdesc:a5d9816ca66208318b4092a55b9ad988e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves TSP for a real-world graph using a triangular approximation. This function solves the TSP for a real-world graph represented by the Nodes_RWG structure using a triangular approximation approach. It calculates the geographic distances between nodes and builds a distance matrix. The function starts from node 0 and iteratively selects the next unvisited node with the shortest distance. It continues this process until all nodes are visited, forming a Hamiltonian cycle. The resulting path is stored in the bestPath vector, and the minimum cost is calculated based on this path.  <a href="class_graph.html#a5d9816ca66208318b4092a55b9ad988e">More...</a><br /></td></tr>
<tr class="separator:a5d9816ca66208318b4092a55b9ad988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab277804b958e9fa0788429621b2ce64c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab277804b958e9fa0788429621b2ce64c">backtrack</a> (vector&lt; int &gt; &amp;path, vector&lt; bool &gt; &amp;visited, int current, double cost)</td></tr>
<tr class="memdesc:ab277804b958e9fa0788429621b2ce64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs backtracking to find the optimal Hamiltonian cycle (TSP solution). The algorithm explores all possible paths starting from node 0 and visiting each unvisited node exactly once. The function updates the minimum cost (minCost) and the best path (bestPath) whenever a better solution is found.  <a href="class_graph.html#ab277804b958e9fa0788429621b2ce64c">More...</a><br /></td></tr>
<tr class="separator:ab277804b958e9fa0788429621b2ce64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6f41f6163eabf16dae592fca1f01c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8ee6f41f6163eabf16dae592fca1f01c">calculateCost</a> (const std::vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a8ee6f41f6163eabf16dae592fca1f01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of a given path in the graph.  <a href="class_graph.html#a8ee6f41f6163eabf16dae592fca1f01c">More...</a><br /></td></tr>
<tr class="separator:a8ee6f41f6163eabf16dae592fca1f01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c89f9300992b2ac69104bb7ddcc868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a00c89f9300992b2ac69104bb7ddcc868">resetVisited</a> ()</td></tr>
<tr class="memdesc:a00c89f9300992b2ac69104bb7ddcc868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the visited flag for all nodes in the graph.  <a href="class_graph.html#a00c89f9300992b2ac69104bb7ddcc868">More...</a><br /></td></tr>
<tr class="separator:a00c89f9300992b2ac69104bb7ddcc868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d904edca96118ab34449d5ff9761fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a40d904edca96118ab34449d5ff9761fe">calculateDistance</a> (int origin, int destination)</td></tr>
<tr class="memdesc:a40d904edca96118ab34449d5ff9761fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between two nodes using their geographic coordinates. It uses the Haversine formula to compute the great-circle distance between the two points on the Earth's surface.  <a href="class_graph.html#a40d904edca96118ab34449d5ff9761fe">More...</a><br /></td></tr>
<tr class="separator:a40d904edca96118ab34449d5ff9761fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab305082de840439075d909d5ae97a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aab305082de840439075d909d5ae97a38">calculateGeographicDistances</a> ()</td></tr>
<tr class="memdesc:aab305082de840439075d909d5ae97a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the geographic distances between nodes and populate the distance matrix.  <a href="class_graph.html#aab305082de840439075d909d5ae97a38">More...</a><br /></td></tr>
<tr class="separator:aab305082de840439075d909d5ae97a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10c4a0ead77531d1d4e298d5720db34"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac10c4a0ead77531d1d4e298d5720db34">calculatePathCost</a> (const vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:ac10c4a0ead77531d1d4e298d5720db34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of a given path in the graph.  <a href="class_graph.html#ac10c4a0ead77531d1d4e298d5720db34">More...</a><br /></td></tr>
<tr class="separator:ac10c4a0ead77531d1d4e298d5720db34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34de057443112c13b150c60e37a68906"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a34de057443112c13b150c60e37a68906">calculateHaversineDistance</a> (double lat1, double lon1, double lat2, double lon2)</td></tr>
<tr class="memdesc:a34de057443112c13b150c60e37a68906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Haversine distance between two geographic coordinates.  <a href="class_graph.html#a34de057443112c13b150c60e37a68906">More...</a><br /></td></tr>
<tr class="separator:a34de057443112c13b150c60e37a68906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46002b237bde23afc97582dcc0a38611"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a46002b237bde23afc97582dcc0a38611">toRadians</a> (double degrees)</td></tr>
<tr class="memdesc:a46002b237bde23afc97582dcc0a38611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <a href="class_graph.html#a46002b237bde23afc97582dcc0a38611">More...</a><br /></td></tr>
<tr class="separator:a46002b237bde23afc97582dcc0a38611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&#160;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe4afa47b86c9ced3a3c64873ea9388a" name="afe4afa47b86c9ced3a3c64873ea9388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4afa47b86c9ced3a3c64873ea9388a">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destino</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distancia</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The ID of the origin node of the edge. </td></tr>
    <tr><td class="paramname">destination</td><td>The ID of the destination node of the edge. </td></tr>
    <tr><td class="paramname">distance</td><td>The distance associated with the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="ae5783fef9d7c4a7776358ab1b18ca8a7" name="ae5783fef9d7c4a7776358ab1b18ca8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5783fef9d7c4a7776358ab1b18ca8a7">&#9670;&#160;</a></span>addEdge_RWG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge_RWG </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds an edge to the graph for Real World Graphs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The ID of the origin node of the edge. </td></tr>
    <tr><td class="paramname">destination</td><td>The ID of the destination node of the edge. </td></tr>
    <tr><td class="paramname">distance</td><td>The distance associated with the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="ad95aef3970ce701d8f89ad4485127f99" name="ad95aef3970ce701d8f89ad4485127f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95aef3970ce701d8f89ad4485127f99">&#9670;&#160;</a></span>addNode_RWG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addNode_RWG </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a node to the graph for Real World Graphs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the node to add. </td></tr>
    <tr><td class="paramname">longitude</td><td>The longitude of the node's location. </td></tr>
    <tr><td class="paramname">latitude</td><td>The latitude of the node's location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="ab277804b958e9fa0788429621b2ce64c" name="ab277804b958e9fa0788429621b2ce64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab277804b958e9fa0788429621b2ce64c">&#9670;&#160;</a></span>backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::backtrack </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs backtracking to find the optimal Hamiltonian cycle (TSP solution). The algorithm explores all possible paths starting from node 0 and visiting each unvisited node exactly once. The function updates the minimum cost (minCost) and the best path (bestPath) whenever a better solution is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector representing the current path being explored. </td></tr>
    <tr><td class="paramname">visited</td><td>A vector indicating whether each node has been visited or not. </td></tr>
    <tr><td class="paramname">current</td><td>The current node being visited. </td></tr>
    <tr><td class="paramname">cost</td><td>The cost of the current path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n!) </dd></dl>

</div>
</div>
<a id="a8ee6f41f6163eabf16dae592fca1f01c" name="a8ee6f41f6163eabf16dae592fca1f01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee6f41f6163eabf16dae592fca1f01c">&#9670;&#160;</a></span>calculateCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculateCost </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of a given path in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector representing the path for which to calculate the cost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n) </dd></dl>

</div>
</div>
<a id="a40d904edca96118ab34449d5ff9761fe" name="a40d904edca96118ab34449d5ff9761fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d904edca96118ab34449d5ff9761fe">&#9670;&#160;</a></span>calculateDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculateDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance between two nodes using their geographic coordinates. It uses the Haversine formula to compute the great-circle distance between the two points on the Earth's surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The ID of the origin node. </td></tr>
    <tr><td class="paramname">destination</td><td>The ID of the destination node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the origin and destination nodes in meters. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="aab305082de840439075d909d5ae97a38" name="aab305082de840439075d909d5ae97a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab305082de840439075d909d5ae97a38">&#9670;&#160;</a></span>calculateGeographicDistances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::calculateGeographicDistances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the geographic distances between nodes and populate the distance matrix. </p>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n^2) </dd></dl>

</div>
</div>
<a id="a34de057443112c13b150c60e37a68906" name="a34de057443112c13b150c60e37a68906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34de057443112c13b150c60e37a68906">&#9670;&#160;</a></span>calculateHaversineDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculateHaversineDistance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the Haversine distance between two geographic coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>Latitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">lon1</td><td>Longitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">lat2</td><td>Latitude of the second point in degrees. </td></tr>
    <tr><td class="paramname">lon2</td><td>Longitude of the second point in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Haversine distance between the two points in meters. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="ac10c4a0ead77531d1d4e298d5720db34" name="ac10c4a0ead77531d1d4e298d5720db34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10c4a0ead77531d1d4e298d5720db34">&#9670;&#160;</a></span>calculatePathCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculatePathCost </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of a given path in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path for which to calculate the cost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of the path. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n) </dd></dl>

</div>
</div>
<a id="a1638b7cf4d451d148b3db8377372b0e1" name="a1638b7cf4d451d148b3db8377372b0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1638b7cf4d451d148b3db8377372b0e1">&#9670;&#160;</a></span>getBestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::getBestPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best path found in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The best path as a vector of node IDs. </dd></dl>

</div>
</div>
<a id="a27e437958267353f4d3b889a16828b6e" name="a27e437958267353f4d3b889a16828b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e437958267353f4d3b889a16828b6e">&#9670;&#160;</a></span>getDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance between two nodes in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The ID of the source node. </td></tr>
    <tr><td class="paramname">destination</td><td>The ID of the destination node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the source and destination nodes. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="aa9584cbd89db821348d0e019ee9457ae" name="aa9584cbd89db821348d0e019ee9457ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9584cbd89db821348d0e019ee9457ae">&#9670;&#160;</a></span>getMinCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getMinCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum cost of the best path found. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum cost of the best path. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="a00c89f9300992b2ac69104bb7ddcc868" name="a00c89f9300992b2ac69104bb7ddcc868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c89f9300992b2ac69104bb7ddcc868">&#9670;&#160;</a></span>resetVisited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::resetVisited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the visited flag for all nodes in the graph. </p>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n) </dd></dl>

</div>
</div>
<a id="a46002b237bde23afc97582dcc0a38611" name="a46002b237bde23afc97582dcc0a38611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46002b237bde23afc97582dcc0a38611">&#9670;&#160;</a></span>toRadians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::toRadians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>Angle in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle in radians. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="a475e4fc3514ebd7c0e6cb085a052a50f" name="a475e4fc3514ebd7c0e6cb085a052a50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475e4fc3514ebd7c0e6cb085a052a50f">&#9670;&#160;</a></span>tspBacktracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBacktracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves TSP using backtracking. </p>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n!) </dd></dl>

</div>
</div>
<a id="a631d624a7d508563ac165fe1add39e7f" name="a631d624a7d508563ac165fe1add39e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631d624a7d508563ac165fe1add39e7f">&#9670;&#160;</a></span>tspBacktracking_RWG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBacktracking_RWG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves TSP for a real-world graph using backtracking. </p>
<dl class="section note"><dt>Note</dt><dd>It finds the optimal Hamiltonian cycle in the graph using a backtracking approach. </dd>
<dd>
Time complexity -&gt; O(n) </dd></dl>

</div>
</div>
<a id="a99ed70e7026d9638753681e0c052f7cb" name="a99ed70e7026d9638753681e0c052f7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ed70e7026d9638753681e0c052f7cb">&#9670;&#160;</a></span>tspBacktrackingUtil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBacktrackingUtil </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for the backtracking algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currNode</td><td>The current node being visited. </td></tr>
    <tr><td class="paramname">depth</td><td>The current depth of the recursion. </td></tr>
    <tr><td class="paramname">currCost</td><td>The current cost of the path being explored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n!) </dd></dl>

</div>
</div>
<a id="a5d9816ca66208318b4092a55b9ad988e" name="a5d9816ca66208318b4092a55b9ad988e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9816ca66208318b4092a55b9ad988e">&#9670;&#160;</a></span>tspTriangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspTriangularApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves TSP for a real-world graph using a triangular approximation. This function solves the TSP for a real-world graph represented by the Nodes_RWG structure using a triangular approximation approach. It calculates the geographic distances between nodes and builds a distance matrix. The function starts from node 0 and iteratively selects the next unvisited node with the shortest distance. It continues this process until all nodes are visited, forming a Hamiltonian cycle. The resulting path is stored in the bestPath vector, and the minimum cost is calculated based on this path. </p>
<dl class="section note"><dt>Note</dt><dd>Time complexity -&gt; O(n^2) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li><a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
